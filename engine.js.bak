'use strict';

/**
 * ===================================================================
 * RUHESTANDSMODELL ENGINE v31.0
 * ===================================================================
 *
 * Enthält die gesamte Kernlogik (Validierung, Marktanalyse,
 * Ausgabenplanung, Transaktionslogik) basierend auf dem
 * Code von "Ruhestand Balance V38.html" (interne v21.1).
 *
 * Stellt zwei Schnittstellen bereit:
 * 1. EngineAPI (Neu): Die saubere, zustandslose API für
 * moderne Aufrufe (z.B. Balance App v38+).
 *
 * 2. Ruhestandsmodell_v30 (Adapter): Ein abwärtskompatibler
 * Adapter für ältere Anwendungen (z.B. Simulator V5),
 * der die alten Funktionssignaturen auf die neue
 * Engine-Logik abbildet.
 *
 * ===================================================================
 */

// --- Globale Versionskonstanten ---
const ENGINE_API_VERSION = "31.0";
const ENGINE_BUILD_ID = new Date().toISOString().substring(0, 16).replace('T', '_');

/*
 * ===================================================================
 * ENGINE API SPEZIFIKATION (v31.0)
 * ===================================================================
 * (Spezifikationstext bleibt unverändert)
 * ===================================================================
 */

/**
 * IIFE (Immediately Invoked Function Expression), um die Kernlogik
 * privat zu kapseln und nur die definierten APIs (EngineAPI und
 * Ruhestandsmodell_v30) an den globalen Scope zu binden.
 */
(function(global) {

    // ===================================================================================
    // 0. SPEZIFISCHE FEHLERKLASSEN
    // ===================================================================================
    class AppError extends Error {
        constructor(message, context = {}) {
            super(message);
            this.context = context;
            this.timestamp = new Date();
        }
    }
    class ValidationError extends AppError {
        constructor(errors) {
            super("Einige Eingaben sind ungültig. Bitte korrigieren Sie die markierten Felder.");
            this.name = 'ValidationError';
            this.errors = errors; // Array von {field, message}
        }
    }
    class FinancialCalculationError extends AppError {
        constructor(message, context) {
            super(message, context);
            this.name = 'FinancialCalculationError';
        }
    }

    // ===================================================================================
    // 1. ZENTRALE KONFIGURATION & KONSTANTEN (EINZIGE QUELLE)
    // ===================================================================================
    const CONFIG = {
        APP: {
            VERSION: ENGINE_API_VERSION,
            NAME: 'Ruhestand-Engine-Core'
        },
        THRESHOLDS: {
            ALARM: {
                withdrawalRate: 0.055,
                realDrawdown: 0.25,
            },
            CAUTION: {
                withdrawalRate: 0.045,
                inflationCap: 3,
            },
            STRATEGY: {
                stagflationInflation: 4,
                runwayThinMonths: 24,
                liquidityBufferZonePercent: 10,
                minRefillAmount: 10000,
                minTradeAmountStatic: 25000,
                minTradeAmountDynamicFactor: 0.005,
                cashRebalanceThreshold: 2500,
                recoveryLiquidityTargetFactor: 0.85
            }
        },
        PROFIL_MAP: {
            'sicherheits-dynamisch': {
                isDynamic: true, minRunwayMonths: 24,
                runway: {
                    'peak': { total: 48 }, 'hot_neutral': { total: 36 }, 'bear': { total: 60 },
                    'stagflation': { total: 60 }, 'recovery_in_bear': { total: 48 }, 'recovery': { total: 48 }
                }
            }
        },
        SPENDING_MODEL: {
            FLEX_RATE_SMOOTHING_ALPHA: 0.35, RATE_CHANGE_MAX_UP_PP: 2.5, RATE_CHANGE_AGILE_UP_PP: 4.5,
            RATE_CHANGE_MAX_DOWN_PP: 3.5, RATE_CHANGE_MAX_DOWN_IN_BEAR_PP: 10.0
        },
        RECOVERY_GUARDRAILS: {
            description: "Vorsichtige Erhöhung der Flex-Rate während Erholungsphasen, abhängig vom Abstand zum ATH.",
            CURB_RULES: [
                { minGap: 25, maxGap: Infinity, curbPercent: 25 },
                { minGap: 15, maxGap: 25,       curbPercent: 20 },
                { minGap: 10, maxGap: 15,       curbPercent: 15 },
                { minGap: 0,  maxGap: 10,       curbPercent: 10 }
            ],
            getCurb(athGapPercent) {
                const rule = this.CURB_RULES.find(c => athGapPercent > c.minGap && athGapPercent <= c.maxGap);
                return rule ? rule.curbPercent : 10;
            }
        },
        TEXTS: {
            SCENARIO: {
                peak_hot: "Markt heiß gelaufen", peak_stable: "Stabiler Höchststand", recovery: "Best. Erholung",
                bear_deep: "Tiefer Bär", corr_young: "Junge Korrektur", side_long: "Seitwärts Lang",
                recovery_in_bear: "Erholung im Bärenmarkt"
            },
            REGIME_MAP: {
                peak_hot: 'peak', peak_stable: 'hot_neutral', side_long: 'hot_neutral', recovery: 'recovery',
                corr_young: 'recovery', bear_deep: 'bear', recovery_in_bear: 'recovery_in_bear'
            }
        }
    };


    // ===================================================================================
    // 2. REINE LOGIK-MODULE (Domain Layer)
    // ===================================================================================

    const InputValidator = {
        validate(input) {
            const errors = [];
            const check = (condition, fieldId, message) => { if (condition) { errors.push({ fieldId, message }); } };

            check(input.aktuellesAlter < 18 || input.aktuellesAlter > 120, 'aktuellesAlter', 'Alter muss zwischen 18 und 120 liegen.');
            check(input.inflation < -10 || input.inflation > 50, 'inflation', 'Inflation außerhalb plausibler Grenzen (-10% bis 50%).');
            
            ['tagesgeld', 'geldmarktEtf', 'depotwertAlt', 'depotwertNeu', 'goldWert', 'floorBedarf', 'flexBedarf', 'costBasisAlt', 'costBasisNeu', 'goldCost', 'sparerPauschbetrag']
                .forEach(field => check(input[field] < 0, field, 'Wert darf nicht negativ sein.'));
            
            ['endeVJ', 'endeVJ_1', 'endeVJ_2', 'endeVJ_3', 'ath']
                .forEach(field => check(input[field] < 0, field, 'Marktdaten dürfen nicht negativ sein.'));

            if(input.goldAktiv) {
                check(input.goldZielProzent <= 0 || input.goldZielProzent > 50, 'goldZielProzent', 'Ziel-Allokation unrealistisch (0-50%).');
                check(input.goldFloorProzent < 0 || input.goldFloorProzent > 20, 'goldFloorProzent', 'Floor-Prozent unrealistisch (0-20%).');
            }

            check(input.runwayMinMonths < 12 || input.runwayMinMonths > 60, 'runwayMinMonths', 'Runway Minimum muss zwischen 12 und 60 Monaten liegen.');
            check(input.runwayTargetMonths < 18 || input.runwayTargetMonths > 72, 'runwayTargetMonths', 'Runway Ziel muss zwischen 18 und 72 Monaten liegen.');
            check(input.runwayTargetMonths < input.runwayMinMonths, 'runwayTargetMonths', 'Runway Ziel darf nicht kleiner als das Minimum sein.');
            
            check(input.targetEq < 20 || input.targetEq > 90, 'targetEq', 'Aktien-Zielquote muss zwischen 20% und 90% liegen.');
            check(input.rebalBand < 1 || input.rebalBand > 20, 'rebalBand', 'Rebalancing-Band muss zwischen 1% und 20% liegen.');
            check(input.maxSkimPctOfEq < 0 || input.maxSkimPctOfEq > 25, 'maxSkimPctOfEq', 'Max. Abschöpfen muss zwischen 0% and 25% liegen.');
            
            check(input.maxBearRefillPctOfEq < 0 || input.maxBearRefillPctOfEq > 15, 'maxBearRefillPctOfEq', 'Max. Auffüllen (Bär) muss zwischen 0% und 15% liegen.');

            return { valid: errors.length === 0, errors };
        }
    };

    const MarketAnalyzer = {
        analyzeMarket(input) {
            const { endeVJ, endeVJ_1, endeVJ_2, endeVJ_3, ath, jahreSeitAth, inflation } = input;

            const abstandVomAthProzent = (ath > 0 && endeVJ > 0) ? ((ath - endeVJ) / ath) * 100 : 0;
            const perf1Y = (endeVJ_1 > 0) ? ((endeVJ - endeVJ_1) / endeVJ_1) * 100 : 0;
            let monateSeitAth = jahreSeitAth * 12;
            if (abstandVomAthProzent > 0 && jahreSeitAth === 0) {
                monateSeitAth = 12;
            }

            let sKey, reasons = [];
            if (abstandVomAthProzent <= 0) {
                sKey = (perf1Y >= 10) ? 'peak_hot' : 'peak_stable';
                reasons.push('Neues Allzeithoch');
                if(perf1Y >= 10) reasons.push('Starkes Momentum (>10%)');
            } else if (abstandVomAthProzent > 20) {
                sKey = 'bear_deep';
                reasons.push(`ATH-Abstand > 20% (${abstandVomAthProzent.toFixed(1)}%)`);
            } else if (abstandVomAthProzent > 10 && perf1Y > 10 && monateSeitAth > 6) {
                sKey = 'recovery';
                reasons.push('Starkes Momentum nach Korrektur');
            } else if (abstandVomAthProzent <= 15 && monateSeitAth <= 6) {
                sKey = 'corr_young';
                reasons.push('Kürzliche, leichte Korrektur');
            } else {
                sKey = 'side_long';
                reasons.push('Seitwärtsphase');
            }

            if (sKey === 'bear_deep' || sKey === 'recovery') {
                const last4years = [endeVJ, endeVJ_1, endeVJ_2, endeVJ_3].filter(v => v > 0);
                const lowPoint = last4years.length > 0 ? Math.min(...last4years) : 0;
                const rallyFromLow = lowPoint > 0 ? ((endeVJ - lowPoint) / lowPoint) * 100 : 0;

                if ((perf1Y >= 15 || rallyFromLow >= 30) && abstandVomAthProzent > 15) {
                    sKey = 'recovery_in_bear';
                    reasons.push(`Erholung im Bärenmarkt (Perf 1J: ${perf1Y.toFixed(0)}%, Rally v. Tief: ${rallyFromLow.toFixed(0)}%)`);
                }
            }
            
            const real1Y = perf1Y - inflation;
            const isStagflation = inflation >= CONFIG.THRESHOLDS.STRATEGY.stagflationInflation && real1Y < 0;
            if(isStagflation) {
                reasons.push(`Stagflation (Inflation ${inflation}% > Realrendite ${real1Y.toFixed(1)}%)`);
            }
            
            const szenarioText = (CONFIG.TEXTS.SCENARIO[sKey] || "Unbekannt") + (isStagflation ? " (Stagflation)" : "");
            
            return { perf1Y, abstandVomAthProzent, sKey, isStagflation, szenarioText, reasons };
        }
    };

    const SpendingPlanner = {
      determineSpending(p) {
        const { lastState, market, inflatedBedarf, runwayMonate, profil, depotwertGesamt, gesamtwert, renteJahr, input } = p;
        
        const diagnosis = { decisionTree: [], guardrails: [], keyParams: {}, general: {} };
        const addDecision = (step, impact, status, severity = 'info') => {
            diagnosis.decisionTree.push({ step, impact, status, severity });
        };

        const state = this._initializeOrLoadState(lastState, p, addDecision);
        
        const alarmStatus = this._evaluateAlarmConditions(state, p, addDecision);
        
        let { geglätteteFlexRate, kuerzungQuelle } = this._calculateFlexRate(state, alarmStatus, p, addDecision);
        
        if (!alarmStatus.active) {
            const guardrailResult = this._applyGuardrails(geglätteteFlexRate, state, { ...p, kuerzungQuelle }, addDecision);
            geglätteteFlexRate = guardrailResult.rate;
            kuerzungQuelle = guardrailResult.source;
        }

        let endgueltigeEntnahme = inflatedBedarf.floor + (inflatedBedarf.flex * (Math.max(0, Math.min(100, geglätteteFlexRate)) / 100));

        const finaleKuerzung = inflatedBedarf.flex > 0 ? 100 - (Math.max(0, endgueltigeEntnahme - inflatedBedarf.floor) / inflatedBedarf.flex * 100) : 0;
        const flexRate = 100 - finaleKuerzung;
        
        const { newState, spendingResult } = this._buildResults(state, endgueltigeEntnahme, alarmStatus, flexRate, kuerzungQuelle, p);
        
        diagnosis.general = { marketSKey: market.sKey, marketSzenario: market.szenarioText, alarmActive: alarmStatus.active, runwayMonate: p.runwayMonate };
        diagnosis.keyParams = state.keyParams;
        diagnosis.guardrails.push(
            { name: "Entnahmequote", value: state.keyParams.entnahmequoteDepot, threshold: CONFIG.THRESHOLDS.ALARM.withdrawalRate, type: 'percent', rule: 'max' },
            { name: "Realer Drawdown (Gesamt)", value: state.keyParams.realerDepotDrawdown, threshold: CONFIG.THRESHOLDS.ALARM.realDrawdown, type: 'percent', rule: 'max' },
            { name: "Runway (vs. Min)", value: runwayMonate, threshold: profil.minRunwayMonths, type: 'months', rule: 'min' }
        );

        return { spendingResult, newState, diagnosis };
    },

        _initializeOrLoadState(lastState, p, addDecision) {
            if (lastState && lastState.initialized) {
                const cumulativeInflationFactor = lastState.cumulativeInflationFactor || 1;
                const realVermögen = p.gesamtwert / cumulativeInflationFactor;
                const peakRealVermoegen = lastState.peakRealVermoegen || realVermögen;
                const realerDepotDrawdown = (peakRealVermoegen > 0) ? (peakRealVermoegen - realVermögen) / peakRealVermoegen : 0;
                const vorlaeufigeEntnahme = p.inflatedBedarf.floor + (p.inflatedBedarf.flex * (lastState.flexRate / 100));
                const entnahmequoteDepot = p.depotwertGesamt > 0 ? vorlaeufigeEntnahme / p.depotwertGesamt : 0;

                return {
                    ...lastState,
                    keyParams: { peakRealVermoegen, currentRealVermoegen: realVermögen, cumulativeInflationFactor, entnahmequoteDepot, realerDepotDrawdown }
                };
            }
            addDecision("System-Initialisierung", "Starte mit 100% Flex-Rate und setze initialen Vermögens-Peak.", "active");
            return {
                flexRate: 100, lastMarketSKey: p.market.sKey, 
                lastTotalBudget: p.inflatedBedarf.floor + p.inflatedBedarf.flex + p.renteJahr,
                peakRealVermoegen: p.gesamtwert, cumulativeInflationFactor: 1,
                initialized: true, alarmActive: false, lastInflationAppliedAtAge: 0,
                keyParams: { peakRealVermoegen: p.gesamtwert, currentRealVermoegen: p.gesamtwert, cumulativeInflationFactor: 1, entnahmequoteDepot: 0, realerDepotDrawdown: 0 }
            };
        },
        
        _shouldDeescalateInPeak(alarmWarAktiv, state, p) {
            if (!alarmWarAktiv || !['peak_hot', 'peak_stable', 'side_long'].includes(p.market.sKey)) return false;
            const { entnahmequoteDepot, realerDepotDrawdown } = state.keyParams;
            return entnahmequoteDepot <= CONFIG.THRESHOLDS.ALARM.withdrawalRate || realerDepotDrawdown <= 0.15;
        },
        
        _shouldDeescalateInRecovery(alarmWarAktiv, state, p) {
            if (!alarmWarAktiv || p.market.sKey !== 'recovery_in_bear') return false;
            const { runwayMonate, profil, input } = p;
            const { entnahmequoteDepot, realerDepotDrawdown } = state.keyParams;
            const okRunway = runwayMonate >= (profil.minRunwayMonths + 6);
            const okDrawdnRecovery = realerDepotDrawdown <= (CONFIG.THRESHOLDS.ALARM.realDrawdown - 0.05);
            const noNewLowerYearlyCloses = input.endeVJ > Math.min(input.endeVJ_1, input.endeVJ_2);
            return (entnahmequoteDepot <= CONFIG.THRESHOLDS.ALARM.withdrawalRate || okRunway || okDrawdnRecovery) && noNewLowerYearlyCloses;
        },

        _evaluateAlarmConditions(state, p, addDecision) {
            const { market, runwayMonate, profil } = p;
            const { entnahmequoteDepot, realerDepotDrawdown } = state.keyParams;
            
            let alarmWarAktiv = state.alarmActive;

            if (this._shouldDeescalateInPeak(alarmWarAktiv, state, p)) {
                alarmWarAktiv = false;
                addDecision("Alarm-Deeskalation (Peak)", "Markt erholt, Drawdown/Quote unkritisch. Alarm wird beendet.", "active", "guardrail");
            } else if (this._shouldDeescalateInRecovery(alarmWarAktiv, state, p)) {
                alarmWarAktiv = false;
                addDecision("Alarm-Deeskalation (Recovery)", "Bedingungen für Entspannung sind erfüllt. Alarm wird beendet.", "active", "guardrail");
            }
            
            const isCrisis = market.sKey === 'bear_deep';
            const isRunwayThin = runwayMonate < CONFIG.THRESHOLDS.STRATEGY.runwayThinMonths;
            const isQuoteCritical = entnahmequoteDepot > CONFIG.THRESHOLDS.ALARM.withdrawalRate;
            const isDrawdownCritical = realerDepotDrawdown > CONFIG.THRESHOLDS.ALARM.realDrawdown;

            const alarmAktivInDieserRunde = !alarmWarAktiv && isCrisis && ((isQuoteCritical && isRunwayThin) || isDrawdownCritical);
            if (alarmAktivInDieserRunde) {
                addDecision("Alarm-Aktivierung!", `Bärenmarkt und kritische Schwelle überschritten. Alarm-Modus AN.`, "active", "alarm");
            }

            return { active: alarmAktivInDieserRunde || alarmWarAktiv, newlyTriggered: alarmAktivInDieserRunde };
        },

        _calculateFlexRate(state, alarmStatus, p, addDecision) {
            if (alarmStatus.active) {
                const kuerzungQuelle = "Guardrail (Alarm)";
                let geglätteteFlexRate = state.flexRate;
                if (alarmStatus.newlyTriggered) { 
                    const shortfallRatio = Math.max(0, (p.profil.minRunwayMonths - p.runwayMonate) / p.profil.minRunwayMonths);
                    const zielCut = Math.min(10, Math.round(10 + 20 * shortfallRatio));
                    geglätteteFlexRate = Math.max(35, state.flexRate - zielCut);
                    addDecision("Anpassung im Alarm-Modus", `Flex-Rate wird auf ${geglätteteFlexRate.toFixed(1)}% gesetzt.`, "active", "alarm");
                } else {
                     addDecision("Anpassung im Alarm-Modus", `Alarm-Modus ist weiterhin aktiv, Rate bleibt bei ${geglätteteFlexRate.toFixed(1)}%.`, "active", "alarm");
                }
                return { geglätteteFlexRate, kuerzungQuelle };
            }
            
            const { market } = p;
            const { FLEX_RATE_SMOOTHING_ALPHA, RATE_CHANGE_MAX_UP_PP, RATE_CHANGE_AGILE_UP_PP, RATE_CHANGE_MAX_DOWN_PP, RATE_CHANGE_MAX_DOWN_IN_BEAR_PP } = CONFIG.SPENDING_MODEL;
            let kuerzungQuelle = "Profil";
            let roheKuerzungProzent = 0;
            if (market.sKey === "bear_deep") {
                roheKuerzungProzent = 50 + Math.max(0, market.abstandVomAthProzent - 20);
                kuerzungQuelle = "Tiefer Bär";
            }

            const roheFlexRate = 100 - roheKuerzungProzent;
            const prevFlexRate = state.flexRate ?? 100;
            let geglätteteFlexRate = FLEX_RATE_SMOOTHING_ALPHA * roheFlexRate + (1 - FLEX_RATE_SMOOTHING_ALPHA) * prevFlexRate;
            
            const delta = geglätteteFlexRate - prevFlexRate;
            const regime = CONFIG.TEXTS.REGIME_MAP[market.sKey];
            let maxUp = (regime === 'peak' || regime === 'hot_neutral' || regime === 'recovery_in_bear') ? RATE_CHANGE_AGILE_UP_PP : RATE_CHANGE_MAX_UP_PP;
            const MAX_DOWN = (market.sKey === 'bear_deep') ? RATE_CHANGE_MAX_DOWN_IN_BEAR_PP : RATE_CHANGE_MAX_DOWN_PP;
            
            if (delta > maxUp) { geglätteteFlexRate = prevFlexRate + maxUp; kuerzungQuelle = "Glättung (Anstieg)"; }
            else if (delta < -MAX_DOWN) { geglätteteFlexRate = prevFlexRate - MAX_DOWN; kuerzungQuelle = "Glättung (Abfall)"; }
            
            if (kuerzungQuelle.startsWith("Glättung")) {
                 addDecision("Glättung der Rate", `Veränderung auf max. ${delta > 0 ? maxUp : MAX_DOWN} pp begrenzt.`, "active");
            }
            return { geglätteteFlexRate, kuerzungQuelle };
        },

        _applyGuardrails(rate, state, p, addDecision) {
            const { market, inflatedBedarf, renteJahr, input, runwayMonate, profil, kuerzungQuelle: initialSource } = p;
            const { entnahmequoteDepot } = state.keyParams;
            const isRecoveryContext = (market.sKey === 'recovery_in_bear') || (market.sKey === 'recovery' && market.abstandVomAthProzent >= 15);
            const isCautionContext = (entnahmequoteDepot >= CONFIG.THRESHOLDS.CAUTION.withdrawalRate);
            let kuerzungQuelle = initialSource;
            let geglätteteFlexRate = rate;
            let cautiousRuleApplied = false;

            if (market.sKey === 'recovery_in_bear') {
                const gap = market.abstandVomAthProzent || 0;
                let curb = CONFIG.RECOVERY_GUARDRAILS.getCurb(gap);
                if (runwayMonate < 30) curb = Math.max(curb, 20);
                const maxFlexRate = 100 - curb;
                if (geglätteteFlexRate > maxFlexRate) {
                    geglätteteFlexRate = maxFlexRate;
                    kuerzungQuelle = "Guardrail (Vorsicht)";
                    addDecision("Guardrail (Vorsicht)", `Recovery-Cap: Flex-Rate auf ${maxFlexRate.toFixed(1)}% gekappt.`, "active", "guardrail");
                    cautiousRuleApplied = true;
                }
            }
            
            let inflationCap = input.inflation;
            if (entnahmequoteDepot >= CONFIG.THRESHOLDS.CAUTION.withdrawalRate) {
                const calculatedInflationCap = Math.min(input.inflation, CONFIG.THRESHOLDS.CAUTION.inflationCap);
                if (calculatedInflationCap < input.inflation) {
                    kuerzungQuelle = "Guardrail (Vorsicht)";
                    addDecision("Guardrail (Vorsicht)", `Caution-Cap: Inflationsanpassung auf ${calculatedInflationCap}% begrenzt.`, "active", "guardrail");
                }
                inflationCap = calculatedInflationCap;
                cautiousRuleApplied = true;
            }
            
            const isWeakSource = ["Profil", "Glättung (Anstieg)", "Glättung (Abfall)"].includes(kuerzungQuelle);
            if (isWeakSource && (isRecoveryContext || (isCautionContext && market.sKey !== 'bear_deep'))) {
                kuerzungQuelle = "Guardrail (Vorsicht)";
            }

            const angepasstesMinBudget = state.lastTotalBudget * (1 + inflationCap / 100);
            const geplanteJahresentnahme = inflatedBedarf.floor + (inflatedBedarf.flex * (Math.max(0, Math.min(100, geglätteteFlexRate)) / 100));
            const aktuellesGesamtbudget = geplanteJahresentnahme + renteJahr;
            const noNewLowerYearlyCloses = input.endeVJ > Math.min(input.endeVJ_1, input.endeVJ_2);
            const budgetFloorErlaubt = !['bear_deep', 'recovery_in_bear'].includes(market.sKey) || ((market.abstandVomAthProzent || 0) <= 10 && noNewLowerYearlyCloses && runwayMonate >= Math.max(30, profil.minRunwayMonths + 6));
            
            if (budgetFloorErlaubt && !cautiousRuleApplied && aktuellesGesamtbudget + 1 < angepasstesMinBudget) {
                const benötigteJahresentnahme = Math.max(0, angepasstesMinBudget - renteJahr);
                const nötigeFlexRate = inflatedBedarf.flex > 0 ? Math.min(100, Math.max(0, ((benötigteJahresentnahme - inflatedBedarf.floor) / inflatedBedarf.flex) * 100)) : 0;
                if (nötigeFlexRate > geglätteteFlexRate) {
                  geglätteteFlexRate = nötigeFlexRate;
                  kuerzungQuelle = "Budget-Floor";
                  addDecision(kuerzungQuelle, `Um realen Kaufkraftverlust zu vermeiden, wird Rate auf ${geglätteteFlexRate.toFixed(1)}% angehoben.`, "active", "guardrail");
                }
            }
            return { rate: geglätteteFlexRate, source: kuerzungQuelle };
        },

        _buildResults(state, endgueltigeEntnahme, alarmStatus, flexRate, kuerzungQuelle, p) {
            const { market, renteJahr, inflatedBedarf } = p;
            const { peakRealVermoegen, currentRealVermoegen, cumulativeInflationFactor } = state.keyParams;
            const finaleKuerzung = inflatedBedarf.flex > 0 ? 100 - (Math.max(0, endgueltigeEntnahme - inflatedBedarf.floor) / inflatedBedarf.flex * 100) : 0;
            const aktuellesGesamtbudgetFinal = endgueltigeEntnahme + renteJahr;
            const newState = { ...state, flexRate, lastMarketSKey: market.sKey, lastTotalBudget: aktuellesGesamtbudgetFinal, peakRealVermoegen: Math.max(peakRealVermoegen, currentRealVermoegen), alarmActive: alarmStatus.active, cumulativeInflationFactor: cumulativeInflationFactor, lastInflationAppliedAtAge: state.lastInflationAppliedAtAge };
            delete newState.keyParams;
            const spendingResult = { monatlicheEntnahme: endgueltigeEntnahme / 12, kuerzungProzent: finaleKuerzung, kuerzungQuelle: kuerzungQuelle, anmerkung: `(Flex um ${finaleKuerzung.toFixed(0)}% wg. ${kuerzungQuelle} gekürzt)`, details: { ...state.keyParams, flexRate, endgueltigeEntnahme } };
            return { newState, spendingResult };
        }
    };

    const TransactionEngine = {
        _computeWeights(input, gesamtwert) {
            if (gesamtwert <= 0) return { eqWeight: 0, goldWeight: 0, liqWeight: 0 };
            const aktienwert = input.depotwertAlt + input.depotwertNeu;
            const goldwert = input.goldAktiv ? input.goldWert : 0;
            const liquiditaet = input.tagesgeld + input.geldmarktEtf;
            return { eqWeight: aktienwert / gesamtwert, goldWeight: goldwert / gesamtwert, liqWeight: liquiditaet / gesamtwert };
        },

        calculateTargetLiquidity: (profil, market, inflatedBedarf) => {
            if (!profil.isDynamic) return (inflatedBedarf.floor + inflatedBedarf.flex) * 2;
            const regime = CONFIG.TEXTS.REGIME_MAP[market.sKey];
            const zielMonate = profil.runway[regime]?.total || profil.runway.hot_neutral.total;
            const useFullFlex = (regime === 'peak' || regime === 'hot_neutral');
            const anpassbarerBedarf = useFullFlex ? (inflatedBedarf.floor + inflatedBedarf.flex) : (inflatedBedarf.floor + 0.5 * inflatedBedarf.flex);
            return (Math.max(1, anpassbarerBedarf) / 12) * zielMonate;
        },

        _computeCappedRefill({ isBearContext, liquiditaetsbedarf, aktienwert, input }) {
            const capConfig = isBearContext
                ? { pct: input.maxBearRefillPctOfEq, title: 'Bärenmarkt-Auffüllung (Drip)', diagStep: 'Cap wirksam (Bär)' }
                : { pct: input.maxSkimPctOfEq,       title: 'Opportunistisches Rebalancing (Skim & Fill)', diagStep: 'Cap wirksam (Skim)' };

            const maxCapEuro = (capConfig.pct / 100) * aktienwert;
            const nettoBedarf = Math.min(liquiditaetsbedarf, maxCapEuro);
            const isCapped = nettoBedarf < liquiditaetsbedarf;
            
            if (nettoBedarf < CONFIG.THRESHOLDS.STRATEGY.minRefillAmount) {
                 if (liquiditaetsbedarf >= CONFIG.THRESHOLDS.STRATEGY.minRefillAmount) {
                     return { bedarf: 0, title: '', diagnosisEntries: [{ step: "Aktion unterdrückt", impact: `Geplanter Verkauf (${nettoBedarf.toFixed(0)}€) unter Mindestgröße nach Capping.`, status: 'inactive', severity: 'guardrail' }]};
                 }
                return { bedarf: 0, title: '', diagnosisEntries: [] };
            }

            const title = isCapped ? `${capConfig.title} (Cap aktiv)` : capConfig.title;
            const diagnosisEntries = isCapped 
                ? [{ step: capConfig.diagStep, impact: `Auffüllen auf ${nettoBedarf.toFixed(0)}€ (${capConfig.pct}%) begrenzt.`, status: 'active', severity: 'guardrail' }]
                : [];

            return { bedarf: nettoBedarf, title, diagnosisEntries };
        },

// In TransactionEngine
determineAction(p) {
    const { aktuelleLiquiditaet, depotwertGesamt, zielLiquiditaet, market, spending, minGold, profil, input } = p;
    
    let actionDetails = { bedarf: 0, title: '', diagnosisEntries: [] };
    let isPufferSchutzAktiv = false;
    let verwendungen = { liquiditaet: 0, gold: 0, aktien: 0 };
    const transactionDiagnostics = {
        wasTriggered: false,
        blockReason: 'none',
        blockedAmount: 0,
        equityThresholds: {},
        goldThresholds: {},
        potentialTrade: {}
    };
    const saleContext = { minGold, saleBudgets: {} }; 

    const renteJahr = input.renteAktiv ? input.renteMonatlich * 12 : 0;
    const floorBedarfNetto = Math.max(0, input.floorBedarf - renteJahr);
    const krisenMindestLiquiditaet = (floorBedarfNetto / 12) * input.runwayMinMonths;
    const sicherheitsPuffer = krisenMindestLiquiditaet;
    const isBearRegimeProxy = market.sKey === 'bear_deep' || market.sKey === 'recovery_in_bear';

    if (aktuelleLiquiditaet <= sicherheitsPuffer && isBearRegimeProxy) {
        isPufferSchutzAktiv = true;
        const gap = sicherheitsPuffer - aktuelleLiquiditaet;
        if (gap > 1) { 
            actionDetails.bedarf = Math.max(0, gap);
            actionDetails.title = "Notfall-Verkauf (Puffer-Auffüllung)";
        } else { 
            actionDetails.bedarf = floorBedarfNetto;
            actionDetails.title = "Notfall-Verkauf (Puffer-Sicherung)";
        }
        actionDetails.diagnosisEntries.push({ step: "Puffer-Schutz (Floor-Fill)", impact: `Runway-Sicherung um ${actionDetails.bedarf.toFixed(0)}€`, status: 'active', severity: 'alarm' });
        verwendungen.liquiditaet = actionDetails.bedarf;
    }

    if (!isPufferSchutzAktiv) {
        const gesamtjahresbedarf = floorBedarfNetto + input.flexBedarf;
        const currentRunwayMonths = (gesamtjahresbedarf > 0) ? (aktuelleLiquiditaet / (gesamtjahresbedarf / 12)) : Infinity;
        const aktienwert = input.depotwertAlt + input.depotwertNeu;
        
        if (isBearRegimeProxy && currentRunwayMonths < input.runwayMinMonths) {
            const runwayBedarfEuro = (input.runwayMinMonths - currentRunwayMonths) * (gesamtjahresbedarf / 12);
            actionDetails = this._computeCappedRefill({ isBearContext: true, liquiditaetsbedarf: runwayBedarfEuro, aktienwert, input });
            verwendungen.liquiditaet = actionDetails.bedarf;

        } else if (!isBearRegimeProxy) {
            const investiertesKapital = depotwertGesamt + aktuelleLiquiditaet;
            const minTrade = Math.max(CONFIG.THRESHOLDS.STRATEGY.minTradeAmountStatic, investiertesKapital * CONFIG.THRESHOLDS.STRATEGY.minTradeAmountDynamicFactor);

            const liquiditaetsBedarf = Math.max(0, zielLiquiditaet - aktuelleLiquiditaet);
            let goldKaufBedarf = 0;
            if (input.goldAktiv && input.goldZielProzent > 0) {
                const goldZielwert = investiertesKapital * (input.goldZielProzent / 100);
                const bandPct = (input.rebalancingBand ?? input.rebalBand ?? 35) / 100;
                const goldUntergrenze = goldZielwert * (1 - bandPct);
                if (input.goldWert < goldUntergrenze) {
                    goldKaufBedarf = Math.max(0, goldZielwert - input.goldWert);
                }
            }
            const totalerBedarf = liquiditaetsBedarf + goldKaufBedarf;

            if (totalerBedarf >= minTrade) {
                let maxSellableFromGold = 0;
                if (input.goldAktiv && input.goldZielProzent > 0) {
                    const goldZielwert = investiertesKapital * (input.goldZielProzent / 100);
                    const bandPct = (input.rebalancingBand ?? input.rebalBand ?? 35) / 100;
                    const goldObergrenze = goldZielwert * (1 + bandPct);
                    if (input.goldWert > goldObergrenze) {
                        maxSellableFromGold = input.goldWert - goldZielwert;
                    }
                }
                saleContext.saleBudgets.gold = maxSellableFromGold;

                const aktienZielwert = investiertesKapital * (input.targetEq / 100);
                const aktienObergrenze = aktienZielwert * (1 + (input.rebalBand / 100));
                const aktienUeberschuss = (aktienwert > aktienObergrenze) ? (aktienwert - aktienZielwert) : 0;
                const maxSkimCapEuro = (input.maxSkimPctOfEq / 100) * aktienwert;
                const maxSellableFromEquity = Math.min(aktienUeberschuss, maxSkimCapEuro);
                
                const totalEquityValue = input.depotwertAlt + input.depotwertNeu;
                if (totalEquityValue > 0) {
                    saleContext.saleBudgets.aktien_alt = maxSellableFromEquity * (input.depotwertAlt / totalEquityValue);
                    saleContext.saleBudgets.aktien_neu = maxSellableFromEquity * (input.depotwertNeu / totalEquityValue);
                }

                actionDetails.bedarf = totalerBedarf;
                actionDetails.title = "Opportunistisches Rebalancing & Liquidität auffüllen";
                verwendungen.gold = Math.min(totalerBedarf, goldKaufBedarf);
                verwendungen.liquiditaet = Math.min(totalerBedarf - verwendungen.gold, liquiditaetsBedarf);
            }
        }
    }
    
    const gesamterNettoBedarf = actionDetails.bedarf;
    if (gesamterNettoBedarf <= 0) {
        return { type: 'NONE', anweisungKlasse: 'anweisung-gruen', title: `${market.szenarioText} (Kein Handlungsbedarf)`, diagnosisEntries: actionDetails.diagnosisEntries, transactionDiagnostics };
    }
    
    let saleResult = this.calculateSaleAndTax(gesamterNettoBedarf, input, saleContext, market, isPufferSchutzAktiv);
    
    const minTradeResult = Math.max(CONFIG.THRESHOLDS.STRATEGY.minTradeAmountStatic, (depotwertGesamt + aktuelleLiquiditaet) * CONFIG.THRESHOLDS.STRATEGY.minTradeAmountDynamicFactor);
    if (!saleResult || saleResult.achievedRefill < minTradeResult) {
        return { type: 'NONE', anweisungKlasse: 'anweisung-gruen', title: `${market.szenarioText} (Kein Handlungsbedarf)`, diagnosisEntries: actionDetails.diagnosisEntries, transactionDiagnostics };
    }
    
    const effektiverNettoerloes = saleResult.achievedRefill;

    if (gesamterNettoBedarf > effektiverNettoerloes + 1 && !actionDetails.title.includes('(Cap aktiv)')) {
        actionDetails.title += ' (Cap aktiv)';
    }

    let erloesUebrig = effektiverNettoerloes;

    // ============================================================================
    // BEGINN DER KORREKTUR: Prioritäten bei der Verteilung des Erlöses umkehren
    // ============================================================================

    // 1. PRIORITÄT: Liquidität auffüllen
    const finalLiq = Math.min(erloesUebrig, verwendungen.liquiditaet);
    erloesUebrig -= finalLiq;

    // 2. PRIORITÄT: Gold-Rebalancing (Kauf) durchführen
    const finalGold = Math.min(erloesUebrig, verwendungen.gold);
    erloesUebrig -= finalGold;
    
    // 3. PRIORITÄT (seltener Fall): Aktien-Rebalancing (Kauf) durchführen
    const finalAktien = Math.min(erloesUebrig, verwendungen.aktien);
    
    // ============================================================================
    // ENDE DER KORREKTUR
    // ============================================================================
    
    return {
        type: 'TRANSACTION', anweisungKlasse: 'anweisung-gelb', title: actionDetails.title,
        isPufferSchutzAktiv, nettoErlös: effektiverNettoerloes, quellen: saleResult.breakdown,
        steuer: saleResult.steuerGesamt, 
        verwendungen: { liquiditaet: finalLiq, gold: finalGold, aktien: finalAktien },
        diagnosisEntries: actionDetails.diagnosisEntries,
        transactionDiagnostics
    };
},
		
		calculateSaleAndTax(requestedRefill, input, context, market, isEmergencySale) {
            const keSt = 0.25 * (1 + 0.055 + input.kirchensteuerSatz);
        
            const _calculateSingleSale = (nettoBedarf, pauschbetrag, tranchesToUse) => {
                let finalBreakdown = [], totalBrutto = 0, totalSteuer = 0, pauschbetragVerbraucht = 0;
                let nochZuDeckenderNettoBetrag = nettoBedarf;
                let pauschbetragRest = pauschbetrag;
        
                for (const tranche of tranchesToUse) {
                    if (nochZuDeckenderNettoBetrag <= 0.01) break;
                    
                    let maxBruttoVerkaufbar = tranche.marketValue;
        
                    if (tranche.kind === 'gold' && context.minGold !== undefined) {
                        maxBruttoVerkaufbar = Math.max(0, input.goldWert - context.minGold);
                    }
                    
                    if (context.saleBudgets && context.saleBudgets[tranche.kind] !== undefined) {
                        maxBruttoVerkaufbar = Math.min(maxBruttoVerkaufbar, context.saleBudgets[tranche.kind]);
                    }
        
                    if (maxBruttoVerkaufbar <= 0) continue;
        
                    const gewinnQuote = tranche.marketValue > 0 ? Math.max(0, (tranche.marketValue - tranche.costBasis) / tranche.marketValue) : 0;
        
                    const gewinnBruttoMax = maxBruttoVerkaufbar * gewinnQuote;
                    const steuerpflichtigerAnteilMax = gewinnBruttoMax * (1 - tranche.tqf);
                    const anrechenbarerPauschbetragMax = Math.min(pauschbetragRest, steuerpflichtigerAnteilMax);
                    const finaleSteuerbasisMax = steuerpflichtigerAnteilMax - anrechenbarerPauschbetragMax;
                    const steuerMax = Math.max(0, finaleSteuerbasisMax) * keSt;
                    const maxNettoAusTranche = maxBruttoVerkaufbar - steuerMax;
        
                    if (maxNettoAusTranche <= 0) continue;
        
                    const nettoAusDieserTranche = Math.min(nochZuDeckenderNettoBetrag, maxNettoAusTranche);
                    
                    let zuVerkaufenBrutto;
                    if (nettoAusDieserTranche < maxNettoAusTranche) {
                         zuVerkaufenBrutto = (nettoAusDieserTranche / maxNettoAusTranche) * maxBruttoVerkaufbar;
                    } else {
                        zuVerkaufenBrutto = maxBruttoVerkaufbar;
                    }
        
                    if (zuVerkaufenBrutto < 1) continue;
                    
                    const bruttogewinn = zuVerkaufenBrutto * gewinnQuote;
                    const gewinnNachTFS = bruttogewinn * (1 - tranche.tqf);
                    const anrechenbarerPauschbetrag = Math.min(pauschbetragRest, gewinnNachTFS);
                    const finaleSteuerbasis = gewinnNachTFS - anrechenbarerPauschbetrag;
                    const steuer = Math.max(0, finaleSteuerbasis) * keSt;
                    const nettoErlös = zuVerkaufenBrutto - steuer;
        
                    totalBrutto += zuVerkaufenBrutto; 
                    totalSteuer += steuer;
                    pauschbetragRest -= anrechenbarerPauschbetrag;
                    pauschbetragVerbraucht += anrechenbarerPauschbetrag;
                    nochZuDeckenderNettoBetrag -= nettoErlös;
                    
                    finalBreakdown.push({ kind: tranche.kind, brutto: zuVerkaufenBrutto, steuer, tqf: tranche.tqf, spbUsed: anrechenbarerPauschbetrag, netto: nettoErlös });
                }
                return { 
                    steuerGesamt: totalSteuer, 
                    bruttoVerkaufGesamt: totalBrutto, 
                    achievedRefill: Math.max(0, nettoBedarf - nochZuDeckenderNettoBetrag), 
                    breakdown: finalBreakdown, 
                    pauschbetragVerbraucht: pauschbetragVerbraucht, 
                };
            };
        
            let tranches = {
                aktien_alt: { marketValue: input.depotwertAlt, costBasis: input.costBasisAlt, tqf: input.tqfAlt, kind: 'aktien_alt' },
                aktien_neu: { marketValue: input.depotwertNeu, costBasis: input.costBasisNeu, tqf: input.tqfNeu, kind: 'aktien_neu' },
                gold: (input.goldAktiv && input.goldWert > 0) ? { marketValue: input.goldWert, costBasis: input.goldCost, tqf: input.goldSteuerfrei ? 1.0 : 0.0, kind: 'gold' } : null
            };
            Object.keys(tranches).forEach(key => { if (!tranches[key] || !tranches[key].marketValue) delete tranches[key]; });
            
            const sellOrder = this._getSellOrder(tranches, market, input, context, isEmergencySale);
            const orderedTranches = sellOrder.map(k => tranches[k]);
        
            return _calculateSingleSale(requestedRefill, input.sparerPauschbetrag, orderedTranches);
        },
        
        _getSellOrder(tranches, market, input, context, isEmergencySale) {
            const equityKeys = Object.keys(tranches)
                .filter(k => k.startsWith('aktien'))
                .sort((a, b) => {
                    const tA = tranches[a], tB = tranches[b];
                    const gqA = tA.marketValue > 0 ? Math.max(0, (tA.marketValue - tA.costBasis) / tA.marketValue) : 0;
                    const gqB = tB.marketValue > 0 ? Math.max(0, (tB.marketValue - tB.costBasis) / tB.marketValue) : 0;
                    return (gqA * (1 - tA.tqf)) - (gqB * (1 - tB.tqf));
                });

            const isDefensiveContext = isEmergencySale || market.sKey === 'bear_deep' || market.sKey === 'recovery_in_bear';

            if (isDefensiveContext) {
                const order = ['gold', ...equityKeys];
                return order.filter(k => tranches[k]);
            }

            if (input.goldAktiv && tranches.gold) {
                const depotwertGesamt = (input.depotwertAlt || 0) + (input.depotwertNeu || 0) + (input.goldWert || 0);
                const investiertesKapital = depotwertGesamt + input.tagesgeld + input.geldmarktEtf;
                const goldZielwert = investiertesKapital * (input.goldZielProzent / 100);
                const bandPct = (input.rebalancingBand ?? input.rebalBand ?? 35) / 100;
                const goldObergrenze = goldZielwert * (1 + bandPct);
                
                if (tranches.gold.marketValue > goldObergrenze) {
                    return ['gold', ...equityKeys].filter(k => tranches[k]);
                }
            }

            return [...equityKeys, 'gold'].filter(k => tranches[k]);
        },
		
		mergeSaleResults(res1, res2) {
            if (!res1) return res2;
            if (!res2) return res1;
            const merged = {
                steuerGesamt: (res1.steuerGesamt || 0) + (res2.steuerGesamt || 0),
                bruttoVerkaufGesamt: (res1.bruttoVerkaufGesamt || 0) + (res2.bruttoVerkaufGesamt || 0),
                achievedRefill: (res1.achievedRefill || 0) + (res2.achievedRefill || 0),
                pauschbetragVerbraucht: (res1.pauschbetragVerbraucht || 0) + (res2.pauschbetragVerbraucht || 0),
                breakdown: [...(res1.breakdown || []), ...(res2.breakdown || [])]
            };
            return merged;
        }
    };


    // ===================================================================================
    // 3. INTERNE ORCHESTRIERUNGS-FUNKTION
    // ===================================================================================
    function _internal_calculateModel(input, lastState) {
        const validationResult = InputValidator.validate(input);
        if (!validationResult.valid) return { error: new ValidationError(validationResult.errors) };

        const profil = CONFIG.PROFIL_MAP[input.risikoprofil];
        const aktuelleLiquiditaet = input.tagesgeld + input.geldmarktEtf;
        const depotwertGesamt = input.depotwertAlt + input.depotwertNeu + (input.goldAktiv ? input.goldWert : 0);
        const gesamtwert = depotwertGesamt + aktuelleLiquiditaet;
        const market = MarketAnalyzer.analyzeMarket(input);
        const goldFloorAbs = (input.goldFloorProzent / 100) * gesamtwert;
        const minGold = input.goldAktiv ? goldFloorAbs : 0;
        const renteJahr = input.renteAktiv ? (input.renteMonatlich * 12) : 0;
        const inflatedBedarf = { floor: Math.max(0, input.floorBedarf - renteJahr), flex: input.flexBedarf };
        const neuerBedarf = inflatedBedarf.floor + inflatedBedarf.flex;
        
        const reichweiteMonate = (inflatedBedarf.floor + inflatedBedarf.flex) > 0 
            ? (aktuelleLiquiditaet / ((inflatedBedarf.floor + inflatedBedarf.flex) / 12)) 
            : Infinity;
        
        const { spendingResult, newState, diagnosis } = SpendingPlanner.determineSpending({ market, lastState, inflatedBedarf, runwayMonate: reichweiteMonate, profil, depotwertGesamt, gesamtwert, renteJahr, input });
        
        const zielLiquiditaet = TransactionEngine.calculateTargetLiquidity(profil, market, inflatedBedarf);
        
        const action = TransactionEngine.determineAction({ aktuelleLiquiditaet, depotwertGesamt, zielLiquiditaet, market, spending: spendingResult, minGold, profil, input });

        if (Array.isArray(action.diagnosisEntries) && action.diagnosisEntries.length) {
			diagnosis.decisionTree.push(...action.diagnosisEntries);
		}

        const liqNachTransaktion = aktuelleLiquiditaet + (action.verwendungen?.liquiditaet || 0);
        const jahresGesamtbedarf = inflatedBedarf.floor + inflatedBedarf.flex;
        const runwayMonths = (jahresGesamtbedarf > 0) ? (liqNachTransaktion / (jahresGesamtbedarf / 12)) : Infinity;

        let runwayStatus = 'bad';
        if (runwayMonths >= input.runwayTargetMonths) runwayStatus = 'ok';
        else if (runwayMonths >= input.runwayMinMonths) runwayStatus = 'warn';
        
        return {
            input, newState, diagnosis,
            ui: {
                depotwertGesamt, neuerBedarf, minGold, zielLiquiditaet, market, spending: spendingResult, action,
                liquiditaet: {
                    deckungVorher: zielLiquiditaet > 0 ? (aktuelleLiquiditaet / zielLiquiditaet) * 100 : 100,
                    deckungNachher: zielLiquiditaet > 0 ? (liqNachTransaktion / zielLiquiditaet) * 100 : 100,
                },
                runway: { months: runwayMonths, status: runwayStatus }
            }
        };
    }


    // ===================================================================================
    // 4. NEUE, MODERNE SCHNITTSTELLE (EngineAPI v31)
    // ===================================================================================
    const EngineAPI = {
        getVersion: function() { return { api: ENGINE_API_VERSION, build: ENGINE_BUILD_ID }; },
		getConfig: function() { return CONFIG; },
        analyzeMarket: function(input) { try { return MarketAnalyzer.analyzeMarket(input); } catch (e) { return { error: e.message }; } },
        calculateTargetLiquidity: function(profil, market, inflatedBedarf) { return TransactionEngine.calculateTargetLiquidity(profil, market, inflatedBedarf); },
        simulateSingleYear: function(input, lastState) {
            try { return _internal_calculateModel(input, lastState); } catch (e) {
                if (e instanceof AppError) return { error: e };
                return { error: new AppError("Ein unerwarteter Engine-Fehler ist aufgetreten.", { originalError: e }) };
            }
        },
        addDecision: function(step, impact, status, severity) { console.warn("EngineAPI.addDecision ist veraltet."); },
        updateDecision: function() {}, removeDecision: function() {}
    };


// ===================================================================================
// 5. ADAPTER-SCHICHT FÜR SIMULATOR V5 (Ruhestandsmodell_v30)
// ===================================================================================
const Ruhestandsmodell_v30_Adapter = {
    VERSION: ENGINE_API_VERSION,
    CONFIG: { ...CONFIG, SCENARIO_TEXT: CONFIG.TEXTS?.SCENARIO || {} },
    analyzeMarket: EngineAPI.analyzeMarket,

    calculateTargetLiquidity: function (profil, market, annualNeedOrInflated, inflatedFloor, inflatedFlex) {
        const inflated = (annualNeedOrInflated && typeof annualNeedOrInflated === 'object')
          ? annualNeedOrInflated
          : { floor: Number(inflatedFloor) || 0, flex: Number(inflatedFlex) || 0 };
        return EngineAPI.calculateTargetLiquidity(profil, market, inflated);
    },
    mergeSaleResults: TransactionEngine.mergeSaleResults,

    _lastSimulationResult: null,

    _runFullSimulationAndCache(v30_inputsCtx, lastState) {
        const v38_input = {
            ...v30_inputsCtx,
            renteAktiv: (v30_inputsCtx.pensionAnnual ?? 0) > 0,
            renteMonatlich: (v30_inputsCtx.pensionAnnual ?? 0) / 12,
            endeVJ: v30_inputsCtx.marketData?.endeVJ ?? v30_inputsCtx.endeVJ ?? 0,
            endeVJ_1: v30_inputsCtx.marketData?.endeVJ_1 ?? v30_inputsCtx.endeVJ_1 ?? 0,
            endeVJ_2: v30_inputsCtx.marketData?.endeVJ_2 ?? v30_inputsCtx.endeVJ_2 ?? 0,
            endeVJ_3: v30_inputsCtx.marketData?.endeVJ_3 ?? v30_inputsCtx.endeVJ_3 ?? 0,
            ath: v30_inputsCtx.marketData?.ath ?? v30_inputsCtx.ath ?? 0,
            jahreSeitAth: v30_inputsCtx.marketData?.jahreSeitAth ?? v30_inputsCtx.jahreSeitAth ?? 0
        };
        const fullResult = EngineAPI.simulateSingleYear(v38_input, lastState);
        this._lastSimulationResult = fullResult;
        return fullResult;
    },
    
    determineSpending: function({market, lastState, inflatedFloor, inflatedFlex, runwayMonths, liquidNow, profile, depotValue, inputsCtx, totalWealth}) {
        const fullResult = this._runFullSimulationAndCache(inputsCtx, lastState);
        if (fullResult.error) {
            return { error: fullResult.error, spendingResult: null, newState: lastState };
        }
        return {
            spendingResult: fullResult.ui.spending,
            newState: fullResult.newState,
            diagnosis: fullResult.diagnosis,
            _fullEngineResponse: fullResult
        };
    },
    
    determineAction: function(v30_results, v30_inputsCtx) {
        let fullResult;
        if (this._lastSimulationResult) {
            fullResult = this._lastSimulationResult;
            this._lastSimulationResult = null;
        } else {
            fullResult = this._runFullSimulationAndCache(v30_inputsCtx, v30_results.spending?.details);
        }

        if (fullResult.error) {
            return { error: fullResult.error, title: "Fehler in der Engine" };
        }

        const v38_actionResult = fullResult.ui.action;
        const saleBreakdown = v38_actionResult.quellen || [];
        const aktuelleLiquiditaet = fullResult.input.tagesgeld + fullResult.input.geldmarktEtf;
        const depotwertGesamt = fullResult.input.depotwertAlt + fullResult.input.depotwertNeu + (fullResult.input.goldAktiv ? fullResult.input.goldWert : 0);

        return {
            ...v38_actionResult,
            saleResult: v38_actionResult.type === 'TRANSACTION' ? {
                steuerGesamt: v38_actionResult.steuer,
                bruttoVerkaufGesamt: saleBreakdown.reduce((sum, q) => sum + q.brutto, 0),
                achievedRefill: v38_actionResult.nettoErlös,
                breakdown: saleBreakdown
            } : null,
            liqNachTransaktion: {
                total: aktuelleLiquiditaet + (v38_actionResult.verwendungen?.liquiditaet || 0)
            },
            kaufGold: v38_actionResult.verwendungen?.gold || 0,
            kaufAktien: v38_actionResult.verwendungen?.aktien || 0,
            reason: v38_actionResult.transactionDiagnostics?.blockReason || 'none',
            rebalFlag: !!(v38_actionResult.title?.toLowerCase().includes('rebal')),
            netSaleEquity: saleBreakdown.filter(q => q.kind.startsWith('aktien')).reduce((sum, q) => sum + q.brutto, 0),
            netSaleGold: saleBreakdown.find(q => q.kind === 'gold')?.brutto || 0,
            diagnostics: v38_actionResult.transactionDiagnostics,
            goldWeightBeforePct: depotwertGesamt > 0 ? (fullResult.input.goldWert / depotwertGesamt) * 100 : 0,
            taxRateSalesPct: (v38_actionResult.nettoErlös > 0) ? (v38_actionResult.steuer / v38_actionResult.nettoErlös) * 100 : 0,
            liquidityGapEUR: fullResult.ui.zielLiquiditaet - aktuelleLiquiditaet,
            _fullEngineResponse: fullResult
        };
    },
    
    calculateSaleAndTax: function(requestedRefill, v30_inputsCtx, caps = {}, market) {
        const v38_input = {
            ...v30_inputsCtx,
            tagesgeld: v30_inputsCtx.tagesgeld,
            geldmarktEtf: v30_inputsCtx.geldmarktEtf,
            depotwertAlt: v30_inputsCtx.depotwertAlt,
            depotwertNeu: v30_inputsCtx.depotwertNeu,
            goldWert:     v30_inputsCtx.goldWert,
            costBasisAlt: v30_inputsCtx.costBasisAlt,
            costBasisNeu: v30_inputsCtx.costBasisNeu,
            goldCost:     v30_inputsCtx.goldCost
        };

        const v38_saleResult = TransactionEngine.calculateSaleAndTax(
            requestedRefill,
            v38_input,
            { minGold: caps?.minGold ?? 0 },
            market,
            true
        );

        return { saleResult: v38_saleResult };
    }
};

    // ===================================================================================
    // 6. GLOBALE EXPORTE
    // ===================================================================================
    global.EngineAPI = EngineAPI;
    global.Ruhestandsmodell_v30 = Ruhestandsmodell_v30_Adapter;

})(typeof window !== 'undefined' ? window : this);